<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            polars-redis - Redis + Polars = Analytics Without the Data Warehouse
        </title>
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/reveal.js@4/dist/reset.css"
        />
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/reveal.js@4/dist/reveal.css"
        />
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/reveal.js@4/dist/theme/black.css"
        />
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/highlight.js@11/styles/monokai.min.css"
        />
        <style>
            .reveal h1,
            .reveal h2,
            .reveal h3 {
                text-transform: none;
            }
            .reveal pre {
                width: 100%;
                font-size: 0.48em;
                box-shadow: none;
            }
            .reveal code {
                background: #1e1e1e;
                padding: 0.1em 0.3em;
                border-radius: 4px;
            }
            .reveal pre code {
                padding: 0.8em 1em;
                max-height: 500px;
            }
            .polars-blue {
                color: #4b8bbe;
            }
            .redis-red {
                color: #dc382d;
            }
            .green {
                color: #98c379;
            }
            .orange {
                color: #e5c07b;
            }
            .reveal section {
                text-align: left;
            }
            .reveal section.center {
                text-align: center;
            }
            .reveal ul {
                margin-left: 0.5em;
                font-size: 0.85em;
            }
            .reveal li {
                margin-bottom: 0.3em;
            }
            .reveal .small {
                font-size: 0.65em;
            }
            .reveal .tiny {
                font-size: 0.55em;
            }
            .reveal .columns {
                display: flex;
                gap: 1em;
            }
            .reveal .column {
                flex: 1;
            }
            .reveal h2 {
                font-size: 1.4em;
                margin-bottom: 0.5em;
            }
            .reveal p {
                font-size: 0.8em;
                margin: 0.3em 0;
            }
            .hljs {
                background: #1e1e1e;
            }
            .reveal .highlight-box {
                background: #2d2d2d;
                padding: 0.8em;
                border-radius: 8px;
                border-left: 4px solid #98c379;
            }
            .reveal .problem-box {
                background: #2d2d2d;
                padding: 0.8em;
                border-radius: 8px;
                border-left: 4px solid #dc382d;
            }
            .reveal .warning-box {
                background: #2d2d2d;
                padding: 0.8em;
                border-radius: 8px;
                border-left: 4px solid #e5c07b;
            }
        </style>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <!-- Title -->
                <section class="center">
                    <h1>
                        <span class="polars-blue">polars</span>-<span
                            class="redis-red"
                            >redis</span
                        >
                    </h1>
                    <h3>
                        Query Redis like a database.<br />Transform with
                        Polars.<br />Write back without ETL.
                    </h3>
                    <p class="small" style="margin-top: 2em">
                        github.com/joshrotenberg/polars-redis
                    </p>
                </section>

                <!-- Who is this for -->
                <section>
                    <h2>Is This For You?</h2>
                    <div class="highlight-box">
                        <ul>
                            <li>
                                You have
                                <span class="green">data in Redis already</span>
                                (or want to put it there)
                            </li>
                            <li>
                                You want to
                                <span class="green"
                                    >analyze it without ETL</span
                                >
                                pipelines
                            </li>
                            <li>
                                Your dataset
                                <span class="green">fits in memory</span> (10K -
                                1M documents)
                            </li>
                            <li>
                                You know
                                <span class="polars-blue">Polars</span> (or want
                                to learn)
                            </li>
                        </ul>
                    </div>
                    <p style="margin-top: 1em" class="small">
                        If you're already juggling Redis + Postgres + S3 to
                        answer questions about Redis data, keep watching.
                    </p>
                </section>

                <!-- The Pitch -->
                <section>
                    <h2>What if Redis was your data layer?</h2>
                    <div class="columns">
                        <div class="column">
                            <div class="problem-box">
                                <h3 class="redis-red">Traditional Stack</h3>
                                <ul class="small">
                                    <li>Redis for caching</li>
                                    <li>PostgreSQL for queries</li>
                                    <li>S3/Parquet for analytics</li>
                                    <li>ETL jobs to sync them</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column">
                            <div class="highlight-box">
                                <h3 class="green">With polars-redis</h3>
                                <ul class="small">
                                    <li>Redis for storage</li>
                                    <li>Polars for compute</li>
                                    <li>That's it.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <p style="margin-top: 1em">
                        For the datasets most teams actually have, you might not
                        need the warehouse.
                    </p>
                </section>

                <!-- Hero Example -->
                <section>
                    <h2>The Hero Example</h2>
                    <pre><code class="language-python">import polars as pl
import polars_redis as redis

url = "redis://localhost:6379"

# Redis is just another data source
users = redis.scan_hashes(url, "user:*", {"name": pl.Utf8, "age": pl.Int64})
orders = pl.read_parquet("s3://bucket/orders.parquet")

# Full Polars transformation power
result = (
    users.join(orders, on="user_id")
    .group_by("region")
    .agg(pl.col("amount").sum().alias("revenue"))
    .sort("revenue", descending=True)
)

# Write back to Redis
redis.write_hashes(result.collect(), url, key_prefix="region_stats:")</code></pre>
                    <p class="small">
                        <span class="green"
                            >Redis becomes a first-class connector</span
                        >
                        alongside Parquet, CSV, and databases.
                    </p>
                </section>

                <!-- What You Get -->
                <section>
                    <h2>What You Get</h2>
                    <div class="columns">
                        <div class="column">
                            <h3 class="polars-blue">DataFrame I/O</h3>
                            <ul>
                                <li>
                                    Scan hashes, JSON, strings, sets, lists,
                                    sorted sets, streams, time series
                                </li>
                                <li>Write DataFrames back</li>
                                <li>Schema inference</li>
                                <li>Projection pushdown</li>
                            </ul>
                        </div>
                        <div class="column">
                            <h3 class="redis-red">RediSearch Integration</h3>
                            <ul>
                                <li>Server-side filtering</li>
                                <li>Server-side aggregation</li>
                                <li>Polars-like query builder</li>
                                <li>Smart scan (auto-detects indexes)</li>
                            </ul>
                        </div>
                        <div class="column">
                            <h3 class="green">Beyond DataFrames</h3>
                            <ul>
                                <li>DataFrame caching</li>
                                <li>Pub/Sub collection</li>
                                <li>Geospatial operations</li>
                                <li>Pipelines & transactions</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- The Problem -->
                <section>
                    <h2>The Old Way</h2>
                    <pre><code class="language-python"># Typical pattern: Fetch everything, process in app
keys = redis.scan_iter("user:*")                      # Iterate all keys
users = []
for key in keys:
    data = redis.hgetall(key)                         # N+1 queries
    users.append(data)

df = pd.DataFrame(users)                              # Manual conversion
df["age"] = df["age"].astype(int)                     # Manual type coercion
df["score"] = df["score"].astype(float)
active = df[df["status"] == "active"]                 # Filter in Python</code></pre>
                    <div class="problem-box" style="margin-top: 0.5em">
                        <ul>
                            <li>
                                <span class="redis-red">N+1 queries</span> for N
                                keys
                            </li>
                            <li>
                                <span class="redis-red"
                                    >Manual type conversion</span
                                >
                            </li>
                            <li>
                                <span class="redis-red"
                                    >All data transferred</span
                                >, then filtered client-side
                            </li>
                        </ul>
                    </div>
                </section>

                <!-- The New Way -->
                <section>
                    <h2>The New Way</h2>
                    <div class="columns">
                        <div class="column">
                            <h3 class="green">Scan</h3>
                            <pre><code class="language-python">df = redis.scan_hashes(
    url, "user:*",
    schema={
        "name": pl.Utf8,
        "age": pl.Int64,
        "status": pl.Utf8
    }
).filter(
    pl.col("status") == "active"
).collect()</code></pre>
                        </div>
                        <div class="column">
                            <h3 class="green">Or Search (with index)</h3>
                            <pre><code class="language-python">from polars_redis import col

df = redis.search_hashes(
    url, index="users_idx",
    query=col("status") == "active",
    schema={
        "name": pl.Utf8,
        "age": pl.Int64
    }
).collect()
# Only matching docs transferred!</code></pre>
                        </div>
                    </div>
                    <div class="highlight-box" style="margin-top: 0.5em">
                        <ul>
                            <li>
                                <span class="green"
                                    >Batched async operations</span
                                >
                                - one call, not N+1
                            </li>
                            <li>
                                <span class="green">Automatic types</span> -
                                schema or inference
                            </li>
                            <li>
                                <span class="green">Predicate pushdown</span> -
                                filter in Redis with RediSearch
                            </li>
                        </ul>
                    </div>
                </section>

                <!-- Query Builder -->
                <section>
                    <h2>RediSearch Query Builder</h2>
                    <p class="small" style="margin-bottom: 0.5em">
                        Build <span class="redis-red">RediSearch</span> queries
                        with Polars-like syntax. Requires a RediSearch index on
                        your data.
                    </p>
                    <div class="columns">
                        <div class="column">
                            <h3 class="polars-blue">Python</h3>
                            <pre><code class="language-python">from polars_redis import col

# Numeric + tag filter
query = (col("age") > 30) & (col("status") == "active")

# Range + multi-tag
query = (
    col("price").is_between(100, 500) &
    col("category").has_any_tag(["electronics", "computers"])
)

# Text search
query = col("title").contains("python")

# Geo search
query = col("location").within_radius(-122.4, 37.7, 10, "km")</code></pre>
                        </div>
                        <div class="column">
                            <h3 class="redis-red">
                                Generated RediSearch Syntax
                            </h3>
                            <pre><code class="language-text"># Numeric + tag filter
@age:[(30 +inf] @status:{active}

# Range + multi-tag
@price:[100 500] @category:{electronics|computers}


# Text search
@title:python

# Geo search
@location:[-122.4 37.7 10 km]</code></pre>
                        </div>
                    </div>
                    <p class="small">
                        No need to learn RediSearch query syntax - use what you
                        know from Polars.
                    </p>
                </section>

                <!-- Server-Side Aggregation -->
                <section>
                    <h2>Server-Side Aggregation</h2>
                    <pre><code class="language-python"># Aggregate in Redis, not Python
df = redis.aggregate_hashes(
    url,
    index="users_idx",
    query="@status:{active}",
    group_by=["@department"],
    reduce=[
        ("COUNT", [], "headcount"),
        ("AVG", ["@salary"], "avg_salary"),
        ("SUM", ["@salary"], "total_payroll"),
    ],
    sort_by=[("@avg_salary", False)],
    limit=10,
)</code></pre>
                    <pre><code class="language-text">| department  | headcount | avg_salary | total_payroll |
|-------------|-----------|------------|---------------|
| engineering | 45        | 125000.0   | 5625000.0     |
| product     | 20        | 115000.0   | 2300000.0     |
| marketing   | 15        | 95000.0    | 1425000.0     |</code></pre>
                    <p class="small">
                        <span class="green"
                            >Only aggregated results transferred</span
                        >
                        - not raw data.
                    </p>
                </section>

                <!-- Smart Scan -->
                <section>
                    <h2>Smart Scan: Automatic Optimization</h2>
                    <pre><code class="language-python">from polars_redis import smart_scan, explain_scan

# Auto-detect index and use FT.SEARCH if available
df = smart_scan(
    url, "user:*",
    schema={"name": pl.Utf8, "age": pl.Int64}
).filter(pl.col("age") > 30).collect()

# Check what it will do before running
plan = explain_scan(url, "user:*", schema={"name": pl.Utf8})
print(plan.explain())</code></pre>
                    <pre><code class="language-text">Strategy: SEARCH
Index: users_idx
  Prefixes: user:
  Type: HASH
Server Query: *</code></pre>
                    <p class="small">
                        If an index exists, <code>smart_scan</code> uses it.
                        Otherwise, falls back to SCAN. Same API either way.
                    </p>
                </section>

                <!-- DataFrame Caching -->
                <section>
                    <h2>DataFrame Caching</h2>
                    <div class="columns">
                        <div class="column">
                            <h3 class="green">@cache Decorator</h3>
                            <pre><code class="language-python">@redis.cache(url=url, ttl=3600)
def expensive_query(start, end):
    return (
        pl.scan_parquet("huge.parquet")
        .filter(pl.col("date").is_between(start, end))
        .group_by("category")
        .agg(pl.sum("revenue"))
        .collect()
    )

# First call: compute + cache
result = expensive_query("2024-01", "2024-12")

# Second call: instant
result = expensive_query("2024-01", "2024-12")</code></pre>
                        </div>
                        <div class="column">
                            <h3 class="orange">Direct API</h3>
                            <pre><code class="language-python"># Cache with compression
redis.cache_dataframe(
    df, url, "result",
    compression="zstd",
    ttl=3600
)

# Retrieve
df = redis.get_cached_dataframe(url, "result")</code></pre>
                            <div
                                class="highlight-box"
                                style="margin-top: 0.5em"
                            >
                                <ul class="small">
                                    <li>Auto-chunking for large DataFrames</li>
                                    <li>Only limited by Redis storage</li>
                                    <li>Arrow IPC or Parquet format</li>
                                    <li>lz4, zstd, gzip compression</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Client Operations -->
                <section>
                    <h2>Redis Operations While You're Here</h2>
                    <p class="small" style="margin-bottom: 0.5em">
                        Common Redis client commands included as a bonus.
                    </p>
                    <div class="columns">
                        <div class="column">
                            <h3 class="redis-red">Geospatial</h3>
                            <pre><code class="language-python"># Add locations
redis.geo_add(url, "stores", [
    ("hq", -122.4, 37.7),
    ("warehouse", -118.2, 34.0),
])

# Find nearby
nearby = redis.geo_radius(
    url, "stores",
    longitude=-122.4,
    latitude=37.8,
    radius=50, unit="km"
)</code></pre>
                        </div>
                        <div class="column">
                            <h3 class="redis-red">Key Management</h3>
                            <pre><code class="language-python"># Bulk TTL
redis.set_ttl(url, keys, 3600)

# Bulk delete by pattern
redis.delete_keys_pattern(url, "temp:*")

# Key info
info = redis.key_info(url, "user:*")
for k in info:
    print(f"{k['key']}: {k['ttl']}s")</code></pre>
                        </div>
                    </div>
                    <div class="columns" style="margin-top: 0.5em">
                        <div class="column">
                            <h3 class="redis-red">Pipelines</h3>
                            <pre><code class="language-python">pipe = redis.Pipeline(url)
pipe.set("a", "1")
pipe.incr("counter")
pipe.hset("user:1", "name", "Alice")
results = pipe.execute()  # One round-trip</code></pre>
                        </div>
                        <div class="column">
                            <h3 class="redis-red">Transactions</h3>
                            <pre><code class="language-python">tx = redis.Transaction(url)
tx.decrby("balance:alice", 100)
tx.incrby("balance:bob", 100)
results = tx.execute()  # Atomic</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Real-time Streaming -->
                <section>
                    <h2>Real-time Data</h2>
                    <div class="columns">
                        <div class="column">
                            <h3 class="redis-red">Pub/Sub to DataFrame</h3>
                            <pre><code class="language-python"># Collect messages
df = redis.collect_pubsub(
    url,
    channels=["events", "alerts"],
    timeout_seconds=10,
    max_messages=1000,
)

# Result: DataFrame with channel, message, timestamp
print(df)
# | channel | message    | timestamp           |
# |---------|------------|---------------------|
# | events  | {"type":   | 2024-01-01 12:00:00 |</code></pre>
                        </div>
                        <div class="column">
                            <h3 class="redis-red">Streams</h3>
                            <pre><code class="language-python"># Consumer group support
df = redis.read_stream(
    url, "mystream",
    group="workers",
    consumer="worker-1",
    schema={"user": pl.Utf8, "action": pl.Utf8}
)

# Continuous iteration
for batch in redis.iter_stream(url, "events"):
    process(batch)</code></pre>
                        </div>
                    </div>
                </section>

                <!-- When NOT to use -->
                <section>
                    <h2>When NOT to Use This</h2>
                    <div class="warning-box">
                        <ul>
                            <li>
                                <span class="orange">100M+ documents?</span> Use
                                a proper data warehouse or Elasticsearch
                            </li>
                            <li>
                                <span class="orange"
                                    >Need ACID transactions?</span
                                >
                                Use PostgreSQL
                            </li>
                            <li>
                                <span class="orange"
                                    >Complex joins across datasets?</span
                                >
                                Use a database
                            </li>
                            <li>
                                <span class="orange"
                                    >Real-time sync to other systems?</span
                                >
                                Not built for that (yet)
                            </li>
                        </ul>
                    </div>
                    <p style="margin-top: 1em" class="small">
                        This is for the <span class="green">sweet spot</span>:
                        datasets that fit in memory, where Redis is already your
                        source of truth, and you want to query without copying
                        data elsewhere.
                    </p>
                </section>

                <!-- Performance -->
                <section>
                    <h2>Performance</h2>
                    <div class="columns">
                        <div class="column">
                            <h3 class="polars-blue">Why It's Fast</h3>
                            <ul>
                                <li>
                                    <span class="green">Rust core</span> -
                                    async, zero-copy Arrow
                                </li>
                                <li>
                                    <span class="green"
                                        >Batched operations</span
                                    >
                                    - pipelined Redis calls
                                </li>
                                <li>
                                    <span class="green"
                                        >Predicate pushdown</span
                                    >
                                    - filter in Redis
                                </li>
                                <li>
                                    <span class="green"
                                        >Projection pushdown</span
                                    >
                                    - fetch only needed fields
                                </li>
                                <li>
                                    <span class="green">Parallel fetching</span>
                                    - configurable workers
                                </li>
                            </ul>
                        </div>
                        <div class="column">
                            <h3 class="orange">Tuning</h3>
                            <pre><code class="language-python"># Batch size
lf = redis.scan_hashes(
    url, "user:*", schema,
    batch_size=5000,
    count_hint=1000,
)

# Parallel workers
lf = redis.scan_hashes(
    url, "user:*", schema,
    parallel=4,
)</code></pre>
                        </div>
                    </div>
                    <div class="highlight-box" style="margin-top: 0.5em">
                        <p class="small">
                            <span class="green">With RediSearch:</span>
                            Server-side filtering can reduce data transfer by
                            90%+ for selective queries.
                        </p>
                    </div>
                </section>

                <!-- Use Cases -->
                <section>
                    <h2>Use Cases</h2>
                    <div class="columns">
                        <div class="column">
                            <h3 class="green">Data Enrichment</h3>
                            <pre><code class="language-python"># Join Redis sessions with warehouse data
sessions = redis.scan_hashes(url, "session:*", schema)
customers = pl.read_parquet("customers.parquet")

engaged = (
    sessions.join(customers, on="user_id")
    .filter(pl.col("page_views") > 10)
)

redis.write_hashes(engaged.collect(), url, key_prefix="engaged:")</code></pre>
                        </div>
                        <div class="column">
                            <h3 class="green">ETL Staging</h3>
                            <pre><code class="language-python"># Redis as fast staging area
df = extract_from_source()
redis.write_hashes(df, url, key_prefix="stage:", ttl=7200)

# Transform with RediSearch
result = redis.aggregate_hashes(url, "stage_idx", ...)

# Load to warehouse
load_to_warehouse(result)</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Installation -->
                <section>
                    <h2>Get Started</h2>
                    <div class="columns">
                        <div class="column">
                            <h3 class="polars-blue">Install</h3>
                            <pre><code class="language-bash">pip install polars-redis</code></pre>
                            <h3 class="redis-red" style="margin-top: 1em">
                                Redis Stack
                            </h3>
                            <pre><code class="language-bash">docker run -d -p 6379:6379 \
  redis/redis-stack:latest</code></pre>
                        </div>
                        <div class="column">
                            <h3 class="green">Try It</h3>
                            <pre><code class="language-python">import polars as pl
import polars_redis as redis

url = "redis://localhost:6379"

# Write
df = pl.DataFrame({"id": [1,2], "name": ["a","b"]})
redis.write_hashes(df, url, key_column="id", key_prefix="test:")

# Read
result = redis.scan_hashes(
    url, "test:*",
    schema={"name": pl.Utf8}
).collect()
print(result)</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Resources -->
                <section>
                    <h2>Resources</h2>
                    <div class="columns">
                        <div class="column">
                            <h3 class="polars-blue">Links</h3>
                            <ul>
                                <li>
                                    Docs:
                                    <a
                                        href="https://joshrotenberg.github.io/polars-redis"
                                        style="color: #4b8bbe"
                                        >joshrotenberg.github.io/polars-redis</a
                                    >
                                </li>
                                <li>
                                    GitHub:
                                    <a
                                        href="https://github.com/joshrotenberg/polars-redis"
                                        style="color: #4b8bbe"
                                        >github.com/joshrotenberg/polars-redis</a
                                    >
                                </li>
                                <li>
                                    PyPI:
                                    <a
                                        href="https://pypi.org/project/polars-redis"
                                        style="color: #4b8bbe"
                                        >pypi.org/project/polars-redis</a
                                    >
                                </li>
                                <li>
                                    crates.io:
                                    <a
                                        href="https://crates.io/crates/polars-redis"
                                        style="color: #4b8bbe"
                                        >crates.io/crates/polars-redis</a
                                    >
                                </li>
                            </ul>
                        </div>
                        <div class="column">
                            <h3 class="green">Requirements</h3>
                            <ul>
                                <li>Python 3.9+</li>
                                <li>Redis 7.0+</li>
                                <li>Redis Stack for RediSearch/JSON</li>
                            </ul>
                            <h3 class="orange" style="margin-top: 1em">
                                Also Available
                            </h3>
                            <ul>
                                <li>Rust crate</li>
                                <li>Redis Cluster support</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Closing -->
                <section class="center">
                    <h1>
                        <span class="polars-blue">polars</span>-<span
                            class="redis-red"
                            >redis</span
                        >
                    </h1>
                    <h3>Stop copying data.<br />Query it where it lives.</h3>
                    <pre><code class="language-bash">pip install polars-redis</code></pre>
                    <p style="margin-top: 2em">
                        github.com/joshrotenberg/polars-redis
                    </p>
                </section>

                <!-- Backup: Supported Types -->
                <section>
                    <h2>Appendix: Supported Redis Types</h2>
                    <table style="font-size: 0.65em; width: 100%">
                        <tr>
                            <th>Redis Type</th>
                            <th>Scan</th>
                            <th>Write</th>
                            <th>Notes</th>
                        </tr>
                        <tr>
                            <td>Hash</td>
                            <td class="green">Yes</td>
                            <td class="green">Yes</td>
                            <td>Field-level projection pushdown</td>
                        </tr>
                        <tr>
                            <td>JSON</td>
                            <td class="green">Yes</td>
                            <td class="green">Yes</td>
                            <td>JSONPath extraction</td>
                        </tr>
                        <tr>
                            <td>String</td>
                            <td class="green">Yes</td>
                            <td class="green">Yes</td>
                            <td>Key-value pairs</td>
                        </tr>
                        <tr>
                            <td>Set / List / Sorted Set</td>
                            <td class="green">Yes</td>
                            <td class="green">Yes</td>
                            <td>One row per member</td>
                        </tr>
                        <tr>
                            <td>Stream</td>
                            <td class="green">Yes</td>
                            <td class="orange">No</td>
                            <td>Consumer groups, timestamps</td>
                        </tr>
                        <tr>
                            <td>TimeSeries</td>
                            <td class="green">Yes</td>
                            <td class="orange">No</td>
                            <td>Server-side aggregation</td>
                        </tr>
                    </table>
                    <p
                        class="small"
                        style="margin-top: 1em; text-align: center"
                    >
                        (backup slide)
                    </p>
                </section>

                <!-- Backup: Architecture -->
                <section>
                    <h2>Appendix: Architecture</h2>
                    <div class="columns" style="text-align: center">
                        <div class="column">
                            <div
                                style="
                                    background: #4b8bbe;
                                    padding: 1em;
                                    border-radius: 8px;
                                    margin-bottom: 0.5em;
                                "
                            >
                                <strong>Python / Polars</strong>
                            </div>
                            <p class="small">
                                LazyFrame API<br />DataFrame ops<br />.collect()
                            </p>
                        </div>
                        <div class="column">
                            <div
                                style="
                                    background: #e5c07b;
                                    color: #1e1e1e;
                                    padding: 1em;
                                    border-radius: 8px;
                                    margin-bottom: 0.5em;
                                "
                            >
                                <strong>polars-redis</strong>
                            </div>
                            <p class="small">
                                Rust + PyO3<br />Async batching<br />Arrow
                                conversion
                            </p>
                        </div>
                        <div class="column">
                            <div
                                style="
                                    background: #dc382d;
                                    padding: 1em;
                                    border-radius: 8px;
                                    margin-bottom: 0.5em;
                                "
                            >
                                <strong>Redis</strong>
                            </div>
                            <p class="small">
                                SCAN + HGETALL<br />FT.SEARCH / FT.AGGREGATE<br />Pub/Sub,
                                Streams
                            </p>
                        </div>
                    </div>
                    <div
                        style="
                            background: #2d2d2d;
                            padding: 0.8em;
                            border-radius: 8px;
                            margin-top: 1em;
                        "
                    >
                        <p class="small" style="margin: 0">
                            <span class="green">io/</span> DataFrame I/O (scan,
                            write, cache, search)
                        </p>
                        <p class="small" style="margin: 0">
                            <span class="green">client/</span> Redis operations
                            (geo, keys, pipeline, pubsub)
                        </p>
                    </div>
                    <p
                        class="small"
                        style="margin-top: 1em; text-align: center"
                    >
                        (backup slide)
                    </p>
                </section>
            </div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/reveal.js@4/dist/reveal.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/reveal.js@4/plugin/highlight/highlight.js"></script>
        <script>
            Reveal.initialize({
                hash: true,
                transition: "slide",
                backgroundTransition: "fade",
                width: 1200,
                height: 700,
                margin: 0.1,
                plugins: [RevealHighlight],
            });
        </script>
    </body>
</html>
